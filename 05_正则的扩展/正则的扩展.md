# 正则的扩展

- 如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
- 字符串的`match`,`replace`,`search`和`split`方法在语言内部全部调用RegExp的实例方法
- ES6 对正则表达式添加了`u`修饰符
- `RegExp.prototype.unicode` 属性,正则实例对象新增unicode属性，表示是否设置了u修饰符。
- `y`修饰符,`g`修饰符只要剩余位置中存在匹配就可，而`y`修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连(sticky)”的涵义。
- `RegExp.prototype.sticky`属性,表示是否设置了y修饰符。
- `RegExp.prototype.flags`属性,返回正则表达式的修饰符
- `s`修饰符,使得`.`可以匹配所有的字符,包括换行`\n`和回车符`\r`等等
- 属性`dotAll`,表示是否设置了`s`修饰符
- 引入后行断言
- ES2018 引入了一种新的类的写法`\p{...}`和`\P{...}`，允许正则表达式匹配符合`Unicode`某种属性的所有字符。
- 具名组匹配,`const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;`
- 如果要在正则表达式内部引用某个“具名组匹配”，可以使用`\k<组名>`的写法。
- `String.prototype.matchAll()`,将全局匹配的结果放进几个遍历器中,并返回这个遍历器
