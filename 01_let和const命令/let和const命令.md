# `let`和`const`命令

## `let`

- `let`声明的变量只在它所在的代码块有效
- for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
- 不存在变量提升
- 暂时性死区
  - 只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
  - 简单来说就是外部有一个变量,内部有一个`let`声明的同名变量,但是内部是在使用这个变量之后才用`let`定义的,就会报错`ReferenceError`
  - `typeof`不再是一个百分百安全的操作
  - 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
- 不允许重复声明

## 块级作用域

- 外层作用域不可以读取内层作用域的内在变量
- 内层作用域可以定义外层作用域的同名变量
- 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。

### 块级作用域与函数声明

- ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。
- 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
- ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

## `const`

- `const`声明一个只读的常量。一旦声明，常量的值就不能改变。
- `const`只能保证变量保存的内存地址的数据不变,当`const`了一个对象的时候要小心
- 如果真的想将对象冻结，应该使用`Object.freeze`方法。
- 其他注意事项与`let`一致
- ES6声明变量的6种方法
  - `var`
  - `function`
  - `let`
  - `const`
  - `import`
  - `class`

## 顶层对象的属性

- `let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性
