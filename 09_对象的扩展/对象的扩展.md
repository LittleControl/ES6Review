# 对象的扩展

## 属性的简洁表示法

- 简写的对象方法不能用作构造函数，会报错

## 属性名表达式

- 属性名表达式与简洁表示法，不能同时使用，会报错
- 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心

## 方法的name属性

- 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set
- 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。
- 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous

## 属性的可枚举性和遍历

## super关键字

- 我们知道，`this`关键字总是指向函数所在的当前对象，ES6又新增了另一个类似的关键字`super`，指向当前对象的原型对象。
- 注意，`super`关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错

## 对象的扩展运算符

扩展运算符`...`

### 解构赋值

- ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式

### 扩展运算符

用于取出参数对象的所有可以遍历的属性,拷贝到当前对象之中

## 链判断运算符

- `?.`
- 在链式调用的时候判断，左侧的对象是否为`null`或`undefined`。如果是的，就不再往下运算，而是返回`undefined`

注意事项

- 短路机制
- `delete`运算符
- 括号的影响
- 报错场合
  - 调用构造函数时使用,`new a?.() new a?.b()`
  - 链式判断符后又模板字符串 "a?.`{b}`"
  - 链式判断夫的左侧是`super` `super?.a()`
  - 不能用于左侧赋值 `a?.b = c`
- 右侧不能为10进制数值

## null判断运算符

- `??`
- `const headerText = response.settings.headerText ?? 'Hello, world!';`
- 只有左侧的值为`null`或`undefined`时,才会返回右侧的值
