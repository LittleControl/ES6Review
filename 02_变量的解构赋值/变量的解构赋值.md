# 变量的解构赋值

## 数组的解构赋值

```JavaScript
let [a, b, c] = [1, 2, 3];//这里的分号不可以省略!
console.log(a, b, c)//1, 2, 3
[a, b, c] = [1, , 3]
console.log(a, b, c)//1, undefined, 3
```

- 如果解构不成功, 会返回一个`undefined`
- 如果等号的右边是一个不可遍历的解构,会报错
- 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
- 允许指定默认值
- ES6 内部使用严格相等运算符（===），判断一个位置是否有值
- 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

## 对象的解构赋值

```JavaScript
let {obj1, obj2} = {obj1: 'aaa', obj2: 'bbb'}
let {obj3} = {obj1: 'aaa', obj2: 'bbb'}
console.log(obj1, obj2, obj3)//aaa, bbb, undefined
```

- 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
- 对象的解构赋值是下面形式的简写:`let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };`
- 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
- 对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于`undefined`
- 如果要将一个已经声明的变量用于解构赋值，必须非常小心。(可能会把等号左边理解为一个代码块)
- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构.`let {0 : first, [arr.length - 1] : last} = arr;`

## 字符串的解构赋值

`const [a, b, c, d, e] = 'hello';`

## 圆括号问题

不可以使用圆括号的情况

- 变量声明语句
- 函数参数
- 赋值语句的模式

可以使用圆括号的情况

- 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号
